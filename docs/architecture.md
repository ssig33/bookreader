# BookReader アーキテクチャ詳細

このドキュメントでは、BookReaderアプリケーションのアーキテクチャ設計と実装の詳細について説明します。

## アプリケーション構造

BookReaderは、Flutterフレームワークを使用したクロスプラットフォームアプリケーションで、以下の主要なレイヤーで構成されています：

```
bookreader/
├── lib/
│   ├── models/      # データモデル
│   ├── screens/     # UI画面
│   ├── services/    # ビジネスロジックとデータ処理
│   └── widgets/     # 再利用可能なUIコンポーネント
└── main.dart        # アプリケーションのエントリーポイント
```

## 主要コンポーネントと役割

### 1. モデル層 (Models)

データ構造を定義し、アプリケーション全体でのデータの一貫性を保証します。

- **Book**: アプリケーションの中心となるモデル
  - 本のメタデータ（ID、タイトル、ファイルパス、ファイルタイプなど）
  - 読書状態（最後に読んだページ、総ページ数など）
  - タグ情報
  - シリアライズ/デシリアライズ機能（JSONとの相互変換）

### 2. サービス層 (Services)

ビジネスロジックとデータ処理を担当します。UIから独立した形で実装されており、テスト容易性と再利用性を高めています。

- **FileService**: ファイル操作の中核
  - ファイルのコピー、削除、存在確認
  - ZIPファイルからの画像抽出とキャッシュ
  - PDFファイルのレンダリング
  - ストレージ使用量の計算

- **BookService**: 本の管理
  - 本の追加、削除、更新
  - タグ管理
  - 本の検索とフィルタリング
  - 読書状態の保存と復元

- **PlatformService**: プラットフォーム固有の機能
  - プラットフォーム検出
  - プラットフォーム固有の機能の有効/無効化（例：PDFサポート）

### 3. 画面層 (Screens)

ユーザーインターフェースを提供し、ユーザー操作を処理します。

- **HomeScreen**: メイン画面
  - 本のリスト表示
  - ファイル追加インターフェース
  - タグフィルタリング
  - 本の管理操作（削除、名前変更など）

- **ReaderScreen**: 閲覧画面
  - 本の内容表示
  - ページナビゲーション
  - 見開き表示の制御
  - 読書設定（ページめくり方向など）

- **StorageInfoScreen**: ストレージ情報画面
  - ストレージ使用量の表示
  - キャッシュ管理

### 4. ウィジェット層 (Widgets)

再利用可能なUIコンポーネントを提供します。

- **BookListItem**: 本のリスト項目
- **ReaderImageLoader**: 画像読み込みと表示
- **ReaderPageLayout**: ページレイアウト（単一/見開き）の制御
- **ReaderNavigation**: ページナビゲーション制御
- **ReaderKeyboardHandler**: キーボード操作の処理

## データフロー

### 1. 本の追加フロー

```
ユーザー操作（ファイル選択/D&D）
    ↓
HomeScreen._pickAndAddBook() / _handleDroppedFiles()
    ↓
BookService.addBook()
    ↓
FileService.copyFileToAppStorage() → アプリストレージにファイルをコピー
    ↓
FileService.getPageCount() → ファイルタイプに応じたページ数取得
    ↓
BookService._saveBooks() → 本のメタデータを保存
    ↓
HomeScreen._loadBooks() → UIを更新
```

### 2. 本の閲覧フロー

```
ユーザー操作（本をタップ）
    ↓
HomeScreen._openBook()
    ↓
ReaderScreen初期化
    ↓
ReaderImageLoader初期化 → ファイルタイプに応じたローダー選択
    ↓
ReaderPageLayout.determinePageLayout() → 見開き表示の判定
    ↓
ReaderNavigation初期化 → ページコントローラーの設定
    ↓
ユーザー操作（ページめくり）
    ↓
ReaderNavigation.goToNextPage() / goToPreviousPage()
    ↓
PageController.animateToPage() / jumpToPage()
    ↓
ReaderScreen._preloadAdjacentPages() → 隣接ページのプリロード
    ↓
BookService.updateLastReadPage() → 読書状態の保存
```

## 状態管理

BookReaderでは、主に以下の方法で状態を管理しています：

1. **ローカルステート**: `StatefulWidget`の`State`クラス内で管理
   - 画面固有の一時的な状態（例：コントロールの表示/非表示）
   - ユーザー入力の処理

2. **永続化ステート**: `SharedPreferences`を使用
   - 本のメタデータ
   - ユーザー設定
   - 最後に読んだページ情報

3. **サービスレイヤーでのキャッシュ**:
   - メモリ内キャッシュ（例：ZIPファイルから抽出した画像）
   - ディスクキャッシュ（抽出した画像の永続化）

## ファイル処理の仕組み

### ZIPファイル処理

1. ZIPファイルをバイトとして読み込み
2. `ZipDecoder`を使用してアーカイブを解凍
3. 画像ファイルのみを抽出し、自然順ソートでソート
4. 抽出した画像をキャッシュディレクトリに保存
5. 必要に応じて画像をメモリにロード

### PDFファイル処理

1. `pdf_image_renderer`ライブラリを使用
2. PDFファイルを開き、ページ数を取得
3. 必要なページを開き、ビットマップとしてレンダリング
4. レンダリングした画像をFlutterのUIに表示
5. 使用後にリソースを解放

## プラットフォーム固有の実装

### PDFサポート

- **Android/iOS**: ネイティブPDFレンダリングAPIを使用
  - Android: PdfRenderer API
  - iOS: CGPDFDocument (Core Graphics)
- **デスクトップ/Web**: PDFサポートなし（プラットフォーム検出で制限）

### ファイル操作

- **モバイル**: アプリケーションのドキュメントディレクトリを使用
- **デスクトップ**: アプリケーション固有のデータディレクトリを使用

## パフォーマンス最適化

### 画像読み込みの最適化

1. **プリロード**: 現在のページの前後のページを事前に読み込み
2. **キャッシュ**: 抽出した画像をディスクとメモリにキャッシュ
3. **遅延読み込み**: 必要なページのみを読み込み

### 見開き表示の最適化

1. **アスペクト比分析**: 画像と画面のアスペクト比に基づいて見開き表示を判断
2. **ちらつき防止**: 見開きモードではアニメーションを無効化（詳細は`reader_screen_flickering_fix.md`を参照）

## 拡張性と将来の展望

### 拡張可能な領域

1. **追加ファイル形式のサポート**:
   - EPUBサポートの追加
   - MOBIサポートの追加

2. **クラウド同期**:
   - 読書進捗の同期
   - 本のメタデータの同期

3. **高度な表示オプション**:
   - カラー調整（ダークモード、ブルーライトフィルターなど）
   - ページめくりアニメーションのカスタマイズ

4. **検索機能**:
   - 本の内容検索
   - OCRを使用したテキスト抽出

### アーキテクチャの進化

現在のアーキテクチャは、サービスベースの設計を採用していますが、将来的には以下の改善が考えられます：

1. **状態管理の改善**:
   - Provider/Riverpodなどの状態管理ライブラリの導入
   - より宣言的なUIの実装

2. **テスト容易性の向上**:
   - 依存性注入の導入
   - モックを使用したユニットテストの拡充

3. **モジュール化**:
   - 機能ごとのパッケージ分割
   - プラグインアーキテクチャの導入（拡張機能のサポート）